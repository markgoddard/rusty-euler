use std::cmp;

/// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
/// Find the sum of all the multiples of 3 or 5 below 1000.
fn problem1() {
    let m3: u32 = (3..1000).step_by(3).sum();
    let m5: u32 = (5..1000).step_by(5).sum();
    let m15: u32 = (15..1000).step_by(15).sum();
    let result = m3 + m5 - m15;
    println!("Problem 1: {result}")
}

/// Return the next and previous terms in the fibonacci sequence.
fn fibonacci(n: u32, np: u32) -> (u32, u32) {
    (n + np, n)
}

/// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
/// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
/// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
fn problem2() {
    let mut n = 1;
    let mut np = 0;
    let mut sum = 0;
    loop {
        if n % 2 == 0 {
            sum += n
        }
        (n, np) = fibonacci(n, np);
        if n >= 4000000 {
            break;
        }
    }
    let result = sum;
    println!("Problem 2: {result}")
}

/// The prime factors of 13195 are 5, 7, 13 and 29.
/// What is the largest prime factor of the number 600851475143 ?
fn problem3() {
    let n = 600851475143;
    let max = (n as f64).sqrt() as u64;
    let mut lpf = 1;
    let mut factors = Vec::new();
    for i in 2..max {
        if n % i == 0 {
            let mut prime = true;
            for factor in &factors {
                if i % factor == 0 {
                    prime = false;
                    break;
                }
            }
            if prime {
                lpf = i
            }
            factors.push(i);
        }
    }
    let result = lpf;
    println!("Problem 3: {result}")
}

fn palindrome(n: u32) -> bool {
    let s = format!("{n}");
    s == s.chars().rev().collect::<String>()
}

// A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
// Find the largest palindrome made from the product of two 3-digit numbers.
fn problem4() {
    let max = 10_u32.pow(3) - 1;
    let mut largest = 1;
    for i in 1..max {
        for j in i..max {
            let product = i * j;
            if product > largest && palindrome(product) {
                largest = product
            }
        }
    }
    let result = largest;
    println!("Problem 4: {result}")
}

// 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
fn problem5() {
    let mut i = 1;
    loop {
        let mut factor = true;
        for prime in 2..20 {
            if i % prime != 0 {
                factor = false;
                break;
            }
        }
        if factor {
            break;
        }
        i += 1;
    }
    let result = i;
    println!("Problem 5: {result}")
}

// The sum of the squares of the first ten natural numbers is,
// 385
// The square of the sum of the first ten natural numbers is,
// 3025
// Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is .
// 2640
// Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
fn problem6() {
    let sum_square: u64 = (1..=100).map(|i: u64| i.pow(2)).sum();
    let square_sum = (1..=100).sum::<u64>().pow(2);
    let result = square_sum - sum_square;
    println!("Problem 6: {result}")
}

// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
// What is the 10001st prime number?
fn problem7() {
    let mut primes = Vec::<u32>::new();
    let mut i = 2;
    loop {
        let mut is_prime = true;
        for prime in &primes {
            if i % prime == 0 {
                is_prime = false;
                break;
            }
        }
        if is_prime {
            primes.push(i);
            if primes.len() == 10001 {
                break;
            }
        }
        i += 1;
    }
    let result = i;
    println!("Problem 7: {result}")
}

// The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
// Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
fn problem8() {
    let n = "
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450";
    let n: Vec<u64> = n
        .chars()
        .filter(|c| c.is_digit(10))
        .map(|c| u64::from(c.to_digit(10).unwrap()))
        .collect();
    let mut max_product = 1;
    for i in 0..(n.len() - 13) {
        let adjacents = &n[i..i + 13];
        let product: u64 = adjacents.iter().product();
        max_product = cmp::max(product, max_product);
    }
    let result = max_product;
    println!("Problem 8: {result}")
}

// A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
// a^2 + b^2 = c^2
// For example, 3^2 + 4^2 = 9 + 16 = 25 = 52.
// There exists exactly one Pythagorean triplet for which a + b + c = 1000.
// Find the product abc.
fn problem9() {
    let mut product = 0;
    for a in 1..998_u32 {
        for b in (a + 1)..(1000 - a) {
            let c = 1000 - a - b;
            if a.pow(2) + b.pow(2) == c.pow(2) {
                product = a * b * c
            }
        }
    }
    let result = product;
    println!("Problem 9: {result}")
}

struct Primes {
    primes: Vec<u32>,
}

impl Primes {
    fn new() -> Primes {
        Primes { primes: Vec::<u32>::new() }
    }
}

impl Iterator for Primes {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        let mut next: u32 = 2;
        match self.primes.last() {
            Some(last) => next = *last + 1,
            None => (),
        }
        loop {
            let mut is_prime = true;
            for prime in &self.primes {
                if next % prime == 0 {
                    is_prime = false;
                    break;
                }
            }
            if is_prime {
                self.primes.push(next);
                return Some(next)
            }
            next += 1
        }
    }
}

// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
// Find the sum of all the primes below two million.
fn problem10() {
    // Could be more efficient with a sieve.
    let primes = Primes::new();
    let mut sum: u64 = 0;
    for prime in primes {
        if prime < 2000000 {
            sum += prime as u64
        } else {
            break
        }
    }
    let result = sum;
    println!("Problem 10: {result}")
}

// In the 20×20 grid below, four numbers along a diagonal line have been marked in red.
// The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
// What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?
fn problem11() {
    let grid = [[08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08],
                [49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00],
                [81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65],
                [52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91],
                [22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80],
                [24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50],
                [32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70],
                [67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21],
                [24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72],
                [21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95],
                [78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92],
                [16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57],
                [86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58],
                [19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40],
                [04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66],
                [88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69],
                [04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36],
                [20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16],
                [20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54],
                [01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48]];
    let mut max_product = 1;

    let sweep = | h: i32, v: i32 | {
        let mut max_product: u32= 1;
        let i0: u32 = if h >= 0 { 0 } else { 3 };
        let imax: u32 = if h <= 0 { 20 } else { 16 };
        let j0: u32 = if v >= 0 { 0 } else { 3 };
        let jmax: u32 = if v <= 0 { 20 } else { 16 };
        for i in i0..imax {
            for j in j0..jmax {
                let product = [
                    grid[j as usize][i as usize],
                    grid[(j as i32 + v) as usize][(i as i32 + h) as usize],
                    grid[(j as i32 + 2 * v) as usize][(i as i32 + 2 * h) as usize],
                    grid[(j as i32 + 3 * v) as usize][(i as i32 + 3 * h) as usize],
                ].iter().product();
                max_product = cmp::max(max_product, product)
            }
        }
        max_product
    };
    max_product = cmp::max(max_product, sweep(1, 0));
    max_product = cmp::max(max_product, sweep(0, 1));
    max_product = cmp::max(max_product, sweep(1, 1));
    max_product = cmp::max(max_product, sweep(1, -1));

    let result = max_product;
    println!("{result}")
}

fn num_factors(n: u32) -> u32 {
    let mut factors = 2; // 1 and n
    let sqrt = (n as f64).sqrt() as u32;
    if sqrt.pow(2) == n { factors += 1 };
    for i in 2..sqrt {
        if n % i == 0 {
            factors += 2;
        }
    }
    factors
}

// The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
// Let us list the factors of the first seven triangle numbers:
//  1: 1
//  3: 1,3
//  6: 1,2,3,6
// 10: 1,2,5,10
// 15: 1,3,5,15
// 21: 1,3,7,21
// 28: 1,2,4,7,14,28
// We can see that 28 is the first triangle number to have over five divisors.
// What is the value of the first triangle number to have over five hundred divisors?
fn problem12() {
    let mut i = 1;
    let mut triangle = i;
    loop {
        if num_factors(triangle) > 500 {
            break
        }
        i += 1;
        triangle += i;
    }
    let result = triangle;
    println!("{result}")
}

pub fn solve_problem(problem: u32) -> Result<(), &'static str> {
    match problem {
        1 => problem1(),
        2 => problem2(),
        3 => problem3(),
        4 => problem4(),
        5 => problem5(),
        6 => problem6(),
        7 => problem7(),
        8 => problem8(),
        9 => problem9(),
        10 => problem10(),
        11 => problem11(),
        12 => problem12(),
        _ => return Err("Unexpected problem number"),
    };
    Ok(())
}
