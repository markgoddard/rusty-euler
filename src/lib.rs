use std::cmp;

/// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
/// Find the sum of all the multiples of 3 or 5 below 1000.
fn problem1() {
    let m3: u32 = (3..1000).step_by(3).sum();
    let m5: u32 = (5..1000).step_by(5).sum();
    let m15: u32 = (15..1000).step_by(15).sum();
    let result = m3 + m5 - m15;
    println!("Problem 1: {result}")
}

/// Return the next and previous terms in the fibonacci sequence.
fn fibonacci(n: u32, np: u32) -> (u32, u32) {
    (n + np, n)
}

/// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
/// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
/// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
fn problem2() {
    let mut n = 1;
    let mut np = 0;
    let mut sum = 0;
    loop {
        if n % 2 == 0 {
            sum += n
        }
        (n, np) = fibonacci(n, np);
        if n >= 4000000 {
            break
        }
    }
    let result = sum;
    println!("Problem 2: {result}")
}

/// The prime factors of 13195 are 5, 7, 13 and 29.
/// What is the largest prime factor of the number 600851475143 ?
fn problem3() {
    let n = 600851475143;
    let max = (n as f64).sqrt() as u64;
    let mut lpf = 1;
    let mut factors = Vec::new();
    for i in 2..max {
        if n % i == 0 {
            let mut prime = true;
            for factor in &factors {
                if i % factor == 0 {
                    prime = false;
                    break;
                }
            }
            if prime {
                lpf = i
            }
            factors.push(i);
        }
    }
    let result = lpf;
    println!("Problem 3: {result}")
}

fn palindrome(n: u32) -> bool {
    let s = format!("{n}");
    s == s.chars().rev().collect::<String>()
}

// A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
// Find the largest palindrome made from the product of two 3-digit numbers.
fn problem4() {
    let max = 10_u32.pow(3) - 1;
    let mut largest = 1;
    for i in 1..max {
        for j in i..max {
            let product = i * j;
            if product > largest && palindrome(product) {
                largest = product
            }
        }
    }
    let result = largest;
    println!("Problem 4: {result}")
}

// 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
fn problem5() {
    let mut i = 1;
    loop {
        let mut factor = true;
        for prime in 2..20 {
            if i % prime != 0 {
                factor = false;
                break
            }
        }
        if factor {
            break;
        }
        i += 1;
    }
    let result = i;
    println!("Problem 5: {result}")
}

// The sum of the squares of the first ten natural numbers is,
// 385
// The square of the sum of the first ten natural numbers is,
// 3025
// Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is .
// 2640
// Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
fn problem6() {
    let sum_square: u64 = (1..=100).map(|i: u64| i.pow(2)).sum();
    let square_sum = (1..=100).sum::<u64>().pow(2);
    let result = square_sum - sum_square;
    println!("Problem 6: {result}")
}

// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
// What is the 10001st prime number?
fn problem7() {
    let mut primes = Vec::<u32>::new();
    let mut i = 2;
    loop {
        let mut is_prime = true;
        for prime in &primes {
            if i % prime == 0 {
                is_prime = false;
                break
            }
        }
        if is_prime {
            primes.push(i);
            if primes.len() == 10001 {
                break
            }
        }
        i += 1;
    }
    let result = i;
    println!("Problem 7: {result}")
}

// The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
// Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
fn problem8() {
    let n = "
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450";
    let n: Vec::<u64> = n.chars().filter(|c| c.is_digit(10)).map(|c| u64::from(c.to_digit(10).unwrap())).collect();
    let mut max_product = 1;
    for i in 0..(n.len() - 13) {
        let adjacents = &n[i..i+13];
        let product: u64 = adjacents.iter().product();
        max_product = cmp::max(product, max_product);
    }
    let result = max_product;
    println!("Problem 8: {result}")
}

pub fn solve_problem(problem: u32) -> Result<(), &'static str> {
    match problem {
        1 => problem1(),
        2 => problem2(),
        3 => problem3(),
        4 => problem4(),
        5 => problem5(),
        6 => problem6(),
        7 => problem7(),
        8 => problem8(),
        _ => {
            return Err("Unexpected problem number")
        },
    };
    Ok(())
}
